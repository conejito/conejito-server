// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-mpromise/a3585faef66f665f3af6ad4e773bbdd35b50a6a9/index.d.ts
declare module '~mongoose~mpromise/index' {
import {EventEmitter} from 'events';

/**
 * An mpromise can be in any of three states, pending, fulfilled (success), or rejected (error). Once it is either fulfilled or rejected it's state can no longer be changed.
 */
class Promise<T> extends EventEmitter implements PromiseLike<T> {
  /**
   * The constructor accepts an optional function which is executed when the promise is first resolved (either fulfilled or rejected).
   */
  constructor(fn?: (err: any, arg: T, ...sink: any[]) => void);

  /**
   * Fulfilling a promise with values
   * If the promise has already been fulfilled or rejected, no action is taken.
   */
  fulfill(arg?: T, ...sink: any[]): void;

  /**
   * Rejecting a promise with a reason.
   * If the promise has already been fulfilled or rejected, no action is taken.
   */
  reject(reason: any): void;

  /**
   * Node.js callback style promise resolution (err, args...).
   * If the promise has already been fulfilled or rejected, no action is taken.
   */
  resolve(reason?: any, arg?: T, ...sink: any[]): this;

  /**
   * To register a function for execution when the promise is fulfilled, pass it to onFulfill. When executed it will receive the arguments passed to fulfill().
   * The function will only be called once when the promise is fulfilled, never when rejected.
   *
   * Registering a function with onFulfill after the promise has already been fulfilled results in the immediate execution of the function with the original arguments used to fulfill the promise.
   */
  onFulfill(fn: (arg: T, ...sink: any[]) => void): this;

  /**
   * To register a function for execution when the promise is rejected, pass it to onReject. When executed it will receive the argument passed to reject().
   * The function will only be called once when the promise is rejected, never when fulfilled.
   *
   * Registering a function with onReject after the promise has already been rejected results in the immediate execution of the function with the original argument used to reject the promise.
   */
  onReject(fn: (reason: any) => void): this;

  /**
   * Allows registration of node.js style callbacks (err, args..) to handle either promise resolution type (fulfill or reject).
   */
  onResolve(fn: (err: any, arg: T, ...sink: any[]) => void): this;

  /**
   * Creates a new promise and returns it. If onFulfill or onReject are passed, they are added as SUCCESS/ERROR callbacks to this promise after the nextTick.
   *
   * Conforms to promises/A+ specification and passes its tests.
   */
  then(onFulfill?: (arg: T, ...sink: any[]) => void | PromiseLike<void>, onReject?: (reason: any) => void | PromiseLike<void>): Promise<void>;
  then<R>(onFulfill?: (arg: T, ...sink: any[]) => R | PromiseLike<R>, onReject?: (reason: any) => R | PromiseLike<R>): Promise<R>;

  /**
   * Signifies that this promise was the last in a chain of then()s: if a handler passed to the call to then which produced this promise throws, the exception be rethrown. You can pass an OnReject handler to end so that exceptions will be handled (like a final catch clause); This method returns it's promise for easy use with return.
   */
  end(fn?: (reason: any) => void): Promise<T>;

  /**
   * Allows direct promise to promise chaining (especially useful by a outside aggregating function). It doesn't use the asynchronous resolve algorithm and so excepts only another Promise as it's argument.
   */
  chain(promise: PromiseLike<T>): Promise<T>;

  // ======================
  // Undocumented functions
  // ======================

  all<R>(fn: (arg: T, ...sink: any[]) => R[] | PromiseLike<R[]> | PromiseLike<R[] | PromiseLike<R[]>>): Promise<R[]>;

  on(event: string, callback: Function): this;

  static fulfilled(): Promise<void>;
  static fulfilled<T>(value: T, ...sink: any[]): Promise<T>;
  static rejected(reason: any): Promise<void>;
  static deferred(): Promise.Deferred<any>;
  static deferred<T>(): Promise.Deferred<T>;

  static hook(array: any[]): Promise<any[]>;
}

namespace Promise {
  const SUCCESS: 'complete';
  const FAILURE: 'err';

  interface Deferred<T> {
    promise: Promise<T>;
    callback: Function;

   reject(reason: any): void;
   resolve(reason?: any, arg?: T, ...sink: any[]): this;
  }
}

export = Promise;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/louy/typed-mongoose/d31d5e6880fb7291290563294237e092b6e09db2/index.d.ts
declare module 'mongoose' {
import * as Promise from '~mongoose~mpromise/index';

export {Promise};

export function connect(uri: string, options?: ConnectionOptions, callback?: (err: any) => void): Mongoose;
export function createConnection(): Connection;
export function createConnection(uri: string, options?: ConnectionOptions): Connection;
export function createConnection(host: string, database_name: string, port?: number, options?: ConnectionOptions): Connection;
export function disconnect(callback?: (err?: any) => void): Mongoose;

export function model<T extends Document>(name: string, schema?: Schema, collection?: string, skipInit?: boolean): Model<T>;
export function modelNames(): string[];
export function plugin(plugin: (schema: Schema, options?: Object) => void, options?: Object): Mongoose;

export function get(key: string): any;
export function set(key: string, value: any): void;

export var mongo: any;
export var mquery: any;
export var version: string;
export var connection: Connection;

export class Mongoose {
  connect(uri: string, options?: ConnectOpenOptionsBase, callback?: (err: any) => void): Mongoose;
  createConnection(): Connection;
  createConnection(uri: string, options?: Object): Connection;
  createConnection(host: string, database_name: string, port?: number, options?: ConnectOpenOptionsBase): Connection;
  disconnect(callback?: (err?: any) => void): Mongoose;
  get(key: string): any;
  model<T extends Document>(name: string, schema?: Schema, collection?: string, skipInit?: boolean): Model<T>;
  modelNames(): string[];
  plugin(plugin: (schema: Schema, options?: Object) => void, options?: Object): Mongoose;
  set(key: string, value: any): void;

  mongo: any;
  mquery: any;
  version: string;
  connection: Connection;
}

export interface Connection extends NodeJS.EventEmitter {
  constructor(base: Mongoose): Connection;

  close(callback?: (err: any) => void): Connection;
  collection(name: string, options?: Object): Collection;
  model<T extends Document>(name: string, schema?: Schema, collection?: string): Model<T>;
  modelNames(): string[];
  open(host: string, database?: string, port?: number, options?: OpenSetConnectionOptions, callback?: (err: any) => void): Connection;
  openSet(uris: string, database?: string, options?: OpenSetConnectionOptions, callback?: (err: any) => void): Connection;

  db: any;
  collections: { [index: string]: Collection };
  readyState: number;
}

export interface ConnectOpenOptionsBase {
  db?: any;
  server?: any;
  replset?: any;
  /** Username for authentication if not supplied in the URI. */
  user?: string;
  /** Password for authentication if not supplied in the URI. */
  pass?: string;
  /** Options for authentication */
  auth?: any;
}

export interface ConnectionOptions extends ConnectOpenOptionsBase {
  /** Passed to the underlying driver's Mongos instance. */
  mongos?: MongosOptions;
}

interface OpenSetConnectionOptions extends ConnectOpenOptionsBase {
  /** If true, enables High Availability support for mongos */
  mongos?: boolean;
}

interface MongosOptions {
  /** Turn on high availability monitoring. (default: true) */
  ha?: boolean;
  /** Time between each replicaset status check. (default: 5000) */
  haInterval?: number;
  /**
   * Number of connections in the connection pool for each
   * server instance. (default: 5 (for legacy reasons))
   */
  poolSize?: number;
  /**
   * Use ssl connection (needs to have a mongod server with
   * ssl support). (default: false).
   */
  ssl?: boolean;
  /**
   * Validate mongod server certificate against ca
   * (needs to have a mongod server with ssl support, 2.4 or higher)
   * (default: true)
   */
  sslValidate?: boolean;
  /** Turn on high availability monitoring. */
  sslCA?: (Buffer | string)[];
  sslKey?: Buffer | string;
  sslPass?: Buffer | string;
  socketOptions?: {
    noDelay?: boolean;
    keepAlive?: number;
    connectionTimeoutMS?: number;
    socketTimeoutMS?: number;
  };
}

export interface Collection {
  drop(callback?: (err: any) => void): Promise<void>;
  initializeOrderedBulkOp(options?: BulkOpOptions): OrderedBulkOperation;
  initializeUnorderedBulkOp(options?: BulkOpOptions): UnorderedBulkOperation;
}

export interface BulkOpOptions {
  w?: number | string;
  wtimeout?: number;
  j?: boolean;
}

export interface OrderedBulkOperation {
  length: number;
  execute(callback: MongoCallback<BulkWriteResult>): void;
  execute(options?: FSyncOptions): Promise<BulkWriteResult>;
  execute(options: FSyncOptions, callback: MongoCallback<BulkWriteResult>): void;
  find(selector: Object): FindOperatorsOrdered;
  insert(doc: Object): OrderedBulkOperation;
}

export interface UnorderedBulkOperation {
  execute(callback: MongoCallback<BulkWriteResult>): void;
  execute(options?: FSyncOptions): Promise<BulkWriteResult>;
  execute(options: FSyncOptions, callback: MongoCallback<BulkWriteResult>): void;
  find(selector: Object): FindOperatorsUnordered;
  insert(doc: Object): UnorderedBulkOperation;
}

export interface MongoCallback<T> {
  (error: MongoError, result: T): void;
}

export class MongoError extends Error {
  constructor(message: string);

  static create(options: Object): MongoError;
}

export interface BulkWriteResult {
  ok: number;
  nInserted: number;
  nUpdated: number;
  nUpserted: number;
  nModified: number;
  nRemoved: number;

  getInsertedIds(): Array<Object>;
  getLastOp(): Object;
  getRawResponse(): Object;
  getUpsertedIdAt(index: number): Object;
  getUpsertedIds(): Array<Object>;
  getWriteConcernError(): WriteConcernError;
  getWriteErrorAt(index: number): WriteError;
  getWriteErrorCount(): number;
  getWriteErrors(): Array<Object>;
  hasWriteErrors(): boolean;
}

export interface WriteError {
  code: number;
  index: number;
  errmsg: string;
}

export interface WriteConcernError {
  code: number;
  errmsg: string;
}

export interface FSyncOptions {
  w?: number | string;
  wtimeout?: number;
  j?: boolean;
  fsync?: boolean
}

export interface FindOperatorsOrdered {
  delete(): OrderedBulkOperation;
  deleteOne(): OrderedBulkOperation;
  replaceOne(doc: Object): OrderedBulkOperation;
  update(doc: Object): OrderedBulkOperation;
  updateOne(doc: Object): OrderedBulkOperation;
  upsert(): FindOperatorsOrdered;
}

export interface FindOperatorsUnordered {
  length: number;
  remove(): UnorderedBulkOperation;
  removeOne(): UnorderedBulkOperation;
  replaceOne(doc: Object): UnorderedBulkOperation;
  update(doc: Object): UnorderedBulkOperation;
  updateOne(doc: Object): UnorderedBulkOperation;
  upsert(): FindOperatorsUnordered;
}

export class SchemaType { }
export class VirtualType {
  get(fn: Function): VirtualType;
  set(fn: Function): VirtualType;
}
export module Types {
  export class ObjectId {
    constructor(id?: string | number);
    toHexString(): string;
    equals(other: ObjectId): boolean;
    getTimestamp(): Date;
    isValid(): boolean;
    static createFromTime(time: number): ObjectId;
    static createFromHexString(hexString: string): ObjectId;
  }
}

export class Schema {
  static Types: {
    String: String;
    ObjectId: Types.ObjectId;
    OId: Types.ObjectId;
    Mixed: any;
  };

  methods: any;
  statics: any;

  constructor(schema?: Object, options?: Object);

  add(obj: Object, prefix?: string): void;
  eachPath(fn: (path: string, type: any) => void): Schema;
  get(key: string): any;
  index(fields: Object, options?: Object): Schema;
  indexes(): void;
  method(name: string, fn: Function): Schema;
  method(method: Object): Schema;
  path(path: string): any;
  path(path: string, constructor: any): Schema;
  pathType(path: string): string;
  plugin(plugin: (schema: Schema, options?: Object) => void, options?: Object): Schema;
  pre(method: string, fn: HookSyncCallback, errorCb?: HookErrorCallback): Schema;
  pre(method: string, isAsync: boolean, fn: HookAsyncCallback, errorCb?: HookErrorCallback): Schema;
  post(method: string, fn: HookSyncCallback, errorCb?: HookErrorCallback): Schema;
  post(method: string, isAsync: boolean, fn: HookAsyncCallback, errorCb?: HookErrorCallback): Schema;
  requiredPaths(): string[];
  set(key: string, value: any): void;
  static(name: string, fn: Function): Schema;
  virtual(name: string, options?: Object): VirtualType;
  virtualpath(name: string): VirtualType;

  toJSON(): Object;
}

// hook functions: https://github.com/vkarpov15/hooks-fixed
export interface HookSyncCallback {
  (next: HookNextFunction, ...hookArgs:any[]): any;
}

export interface HookAsyncCallback {
  (next: HookNextFunction, done: HookDoneFunction, ...hookArgs:any[]): any;
}

export interface HookErrorCallback {
  (error: Error): any;
}

export interface HookNextFunction {
  (error: Error): any;
  (...hookArgs:any[]): any;
}

export interface HookDoneFunction {
  (error: Error): any;
  (...hookArgs:any[]): any;
}

export interface SchemaOption {
  autoIndex?: boolean;
  bufferCommands?: boolean;
  capped?: boolean;
  collection?: string;
  id?: boolean;
  _id?: boolean;
  minimize?: boolean;
  read?: string;
  safe?: boolean;
  shardKey?: boolean;
  strict?: boolean;
  toJSON?: Object;
  toObject?: Object;
  versionKey?: boolean;
}

export interface Model<T extends Document> extends NodeJS.EventEmitter {
  new (doc?: Object): T;

  aggregate(...aggregations: Object[]): Aggregate<T[]>;
  aggregate(aggregation: Object, callback: (err: any, res: T[]) => void): Promise<T[]>;
  aggregate(aggregation1: Object, aggregation2: Object, callback: (err: any, res: T[]) => void): Promise<T[]>;
  aggregate(aggregation1: Object, aggregation2: Object, aggregation3: Object, callback: (err: any, res: T[]) => void): Promise<T[]>;
  count(conditions: Object, callback?: (err: any, count: number) => void): Query<number>;

  create(doc: Object, fn?: (err: any, res: T) => void): Promise<T>;
  create(doc1: Object, doc2: Object, fn?: (err: any, res1: T, res2: T) => void): Promise<T[]>;
  create(doc1: Object, doc2: Object, doc3: Object, fn?: (err: any, res1: T, res2: T, res3: T) => void): Promise<T[]>;
  discriminator<U extends Document>(name: string, schema: Schema): Model<U>;
  distinct(field: string, callback?: (err: any, res: T[]) => void): Query<T[]>;
  distinct(field: string, conditions: Object, callback?: (err: any, res: T[]) => void): Query<T[]>;
  ensureIndexes(callback: (err: any) => void): Promise<T>;

  find(cond: Object, callback?: (err: any, res: T[]) => void): Query<T[]>;
  find(cond: Object, fields: Object, callback?: (err: any, res: T[]) => void): Query<T[]>;
  find(cond: Object, fields: Object, options: Object, callback?: (err: any, res: T[]) => void): Query<T[]>;
  findById(id: string, callback?: (err: any, res: T) => void): Query<T>;
  findById(id: string, fields: Object, callback?: (err: any, res: T) => void): Query<T>;
  findById(id: string, fields: Object, options: Object, callback?: (err: any, res: T) => void): Query<T>;
  findByIdAndRemove(id: string, callback?: (err: any, res: T) => void): Query<T>;
  findByIdAndRemove(id: string, options: Object, callback?: (err: any, res: T) => void): Query<T>;
  findByIdAndUpdate(id: string, update: Object, callback?: (err: any, res: T) => void): Query<T>;
  findByIdAndUpdate(id: string, update: Object, options: FindAndUpdateOption, callback?: (err: any, res: T) => void): Query<T>;
  findOne(cond?: Object, callback?: (err: any, res: T) => void): Query<T>;
  findOne(cond: Object, fields: Object, callback?: (err: any, res: T) => void): Query<T>;
  findOne(cond: Object, fields: Object, options: Object, callback?: (err: any, res: T) => void): Query<T>;
  findOneAndRemove(cond: Object, callback?: (err: any, res: T) => void): Query<T>;
  findOneAndRemove(cond: Object, options: Object, callback?: (err: any, res: T) => void): Query<T>;
  findOneAndUpdate(cond: Object, update: Object, callback?: (err: any, res: T) => void): Query<T>;
  findOneAndUpdate(cond: Object, update: Object, options: FindAndUpdateOption, callback?: (err: any, res: T) => void): Query<T>;

  geoNear(point: { type: string; coordinates: number[] }, options: Object, callback?: (err: any, res: T[]) => void): Query<T[]>;
  geoNear(point: number[], options: Object, callback?: (err: any, res: T[]) => void): Query<T[]>;
  geoSearch(cond: Object, options: GeoSearchOption, callback?: (err: any, res: T[]) => void): Query<T[]>;
  increment(): T;
  mapReduce<K, V>(options: MapReduceOption<T, K, V>, callback?: (err: any, res: MapReduceResult<K, V>[]) => void): Promise<MapReduceResult<K, V>[]>;
  mapReduce<K, V>(options: MapReduceOption2<T, K, V>, callback?: (err: any, res: MapReduceResult<K, V>[]) => void): Promise<MapReduceResult<K, V>[]>;
  model<U extends Document>(name: string): Model<U>;

  populate<U>(doc: U, options: Object, callback?: (err: any, res: U) => void): Promise<U>;
  populate<U>(doc: U[], options: Object, callback?: (err: any, res: U[]) => void): Promise<U[]>;
  update(cond: Object, update: Object, callback?: (err: any, affectedRows: number, raw: any) => void): Query<T>;
  update(cond: Object, update: Object, options: Object, callback?: (err: any, affectedRows: number, raw: any) => void): Query<T>;
  remove(cond: Object, callback?: (err: any) => void): Query<{}>;
  save(callback?: (err: any, result: T, numberAffected: number) => void): Query<T>;
  where(path: string, val?: Object): Query<T[]>;

  $where(argument: string): Query<T>;
  $where(argument: Function): Query<T>;

  base: Mongoose;
  collection: Collection;
  db: any;
  discriminators: any;
  modelName: string;
  schema: Schema;
}
export interface FindAndUpdateOption {
  new?: boolean;
  upsert?: boolean;
  sort?: Object;
  select?: Object;
}
export interface GeoSearchOption {
  near: number[];
  maxDistance: number;
  limit?: number;
  lean?: boolean;
}
export interface MapReduceOption<T extends Document, Key, Val> {
  map: () => void;
  reduce: (key: Key, vals: T[]) => Val;
  query?: Object;
  limit?: number;
  keeptemp?: boolean;
  finalize?: (key: Key, val: Val) => Val;
  scope?: Object;
  jsMode?: boolean;
  verbose?: boolean;
  out?: {
    inline?: number;
    replace?: string;
    reduce?: string;
    merge?: string;
  };
}
export interface MapReduceOption2<T extends Document, Key, Val> {
  map: string;
  reduce: (key: Key, vals: T[]) => Val;
  query?: Object;
  limit?: number;
  keeptemp?: boolean;
  finalize?: (key: Key, val: Val) => Val;
  scope?: Object;
  jsMode?: boolean;
  verbose?: boolean;
  out?: {
    inline?: number;
    replace?: string;
    reduce?: string;
    merge?: string;
  };
}
export interface MapReduceResult<Key, Val> {
  _id: Key;
  value: Val;
}

export class Query<T> {
  exec(callback?: (err: any, res: T) => void): Promise<T>;
  exec(operation: string, callback?: (err: any, res: T) => void): Promise<T>;
  exec(operation: Function, callback?: (err: any, res: T) => void): Promise<T>;

  all(val: number): Query<T>;
  all(path: string, val: number): Query<T>;
  and(array: Object[]): Query<T>;
  box(val: Object): Query<T>;
  box(a: number[], b: number[]): Query<T>;
  batchSize(val: number): Query<T>;
  cast<U extends Document>(model: Model<U>, obj: Object): U;
  //center(): Query<T>;
  //centerSphere(path: string, val: Object): Query<T>;
  circle(area: Object): Query<T>;
  circle(path: string, area: Object): Query<T>;
  comment(val: any): Query<T>;
  count(callback?: (err: any, count: number) => void): Query<number>;
  count(criteria: Object, callback?: (err: any, count: number) => void): Query<number>;
  distinct(callback?: (err: any, res: T) => void): Query<T>;
  distinct(field: string, callback?: (err: any, res: T) => void): Query<T>;
  distinct(criteria: Object, field: string, callback?: (err: any, res: T) => void): Query<T>;
  distinct(criteria: Query<T>, field: string, callback?: (err: any, res: T) => void): Query<T>;
  elemMatch(criteria: Object): Query<T>;
  elemMatch(criteria: (elem: Query<T>) => void): Query<T>;
  elemMatch(path: string, criteria: Object): Query<T>;
  elemMatch(path: string, criteria: (elem: Query<T>) => void): Query<T>;
  equals(val: Object): Query<T>;
  exists(val?: boolean): Query<T>;
  exists(path: string, val?: boolean): Query<T>;
  find(callback?: (err: any, res: T) => void): Query<T>;
  find(criteria: Object, callback?: (err: any, res: T) => void): Query<T>;
  findOne(callback?: (err: any, res: T) => void): Query<T>;
  findOne(criteria: Object, callback?: (err: any, res: T) => void): Query<T>;
  findOneAndRemove(callback?: (err: any, res: T) => void): Query<T>;
  findOneAndRemove(cond: Object, callback?: (err: any, res: T) => void): Query<T>;
  findOneAndRemove(cond: Object, options: Object, callback?: (err: any, res: T) => void): Query<T>;
  findOneAndUpdate(callback?: (err: any, res: T) => void): Query<T>;
  findOneAndUpdate(update: Object, callback?: (err: any, res: T) => void): Query<T>;
  findOneAndUpdate(cond: Object, update: Object, callback?: (err: any, res: T) => void): Query<T>;
  findOneAndUpdate(cond: Object, update: Object, options: FindAndUpdateOption, callback?: (err: any, res: T) => void): Query<T>;
  geometry(object: Object): Query<T>;
  gt(val: number): Query<T>;
  gt(path: string, val: number): Query<T>;
  gte(val: number): Query<T>;
  gte(path: string, val: number): Query<T>;
  hint(val: Object): Query<T>;
  in(val: any[]): Query<T>;
  in(path: string, val: any[]): Query<T>;
  intersects(arg?: Object): Query<T>;
  lean(bool?: boolean): Query<T>;
  limit(val: number): Query<T>;
  lt(val: number): Query<T>;
  lt(path: string, val: number): Query<T>;
  lte(val: number): Query<T>;
  lte(path: string, val: number): Query<T>;
  maxDistance(val: number): Query<T>;
  maxDistance(path: string, val: number): Query<T>;
  maxScan(val: number): Query<T>;
  merge(source: Query<T>): Query<T>;
  merge(source: Object): Query<T>;
  mod(val: number[]): Query<T>;
  mod(path: string, val: number[]): Query<T>;
  ne(val: any): Query<T>;
  ne(path: string, val: any): Query<T>;
  near(val: Object): Query<T>;
  near(path: string, val: Object): Query<T>;
  nearSphere(val: Object): Query<T>;
  nearSphere(path: string, val: Object): Query<T>;
  nin(val: any[]): Query<T>;
  nin(path: string, val: any[]): Query<T>;
  nor(array: Object[]): Query<T>;
  or(array: Object[]): Query<T>;
  polygon(...coordinatePairs: number[][]): Query<T>;
  polygon(path: string, ...coordinatePairs: number[][]): Query<T>;
  populate(path: string, select?: string, match?: Object, options?: Object): Query<T>;
  populate(path: string, select: string, model: string, match?: Object, options?: Object): Query<T>;
  populate(opt: PopulateOption): Query<T>;
  read(pref: string, tags?: Object[]): Query<T>;
  regex(val: RegExp): Query<T>;
  regex(path: string, val: RegExp): Query<T>;
  remove(callback?: (err: any, res: T) => void): Query<T>;
  remove(criteria: Object, callback?: (err: any, res: T) => void): Query<T>;
  select(arg: string): Query<T>;
  select(arg: Object): Query<T>;
  select<T>(arg: string): Query<T>;
  select<T>(arg: Object): Query<T>;
  setOptions(options: Object): Query<T>;
  size(val: number): Query<T>;
  size(path: string, val: number): Query<T>;
  skip(val: number): Query<T>;
  slaveOk(v?: boolean): Query<T>;
  slice(val: number): Query<T>;
  slice(val: number[]): Query<T>;
  slice(path: string, val: number): Query<T>;
  slice(path: string, val: number[]): Query<T>;
  snapshot(v?: boolean): Query<T>;
  sort(arg: Object): Query<T>;
  sort(arg: string): Query<T>;
  stream(options?: { transform?: Function; }): QueryStream;
  tailable(v?: boolean): Query<T>;
  toConstructor(): Query<T>;
  update(callback?: (err: any, affectedRows: number, doc: T) => void): Query<T>;
  update(doc: Object, callback?: (err: any, affectedRows: number, doc: T) => void): Query<T>;
  update(criteria: Object, doc: Object, callback?: (err: any, affectedRows: number, doc: T) => void): Query<T>;
  update(criteria: Object, doc: Object, options: Object, callback?: (err: any, affectedRows: number, doc: T) => void): Query<T>;
  where(path?: string, val?: any): Query<T>;
  where(path?: Object, val?: any): Query<T>;
  within(val?: Object): Query<T>;
  within(coordinate: number[], ...coordinatePairs: number[][]): Query<T>;

  $where(argument: string): Query<T>;
  $where(argument: Function): Query<T>;

  static use$geoWithin: boolean;
}

export interface PopulateOption {
  path: string;
  select?: string;
  model?: string;
  match?: Object;
  options?: Object;
}

export interface QueryStream extends NodeJS.EventEmitter {
  destory(err?: any): void;
  pause(): void;
  resume(): void;
  pipe<T extends NodeJS.WritableStream>(destination: T, options?: { end?: boolean; }): T;
  paused: number;
  readable: boolean;
}

export interface Document {
  id?: string | number;
  _id: Types.ObjectId;

  equals(doc: Document): boolean;
  get(path: string, type?: new (...args: any[]) => any): any;
  inspect(options?: Object): string;
  invalidate(path: string, errorMsg: string, value: any): void;
  invalidate(path: string, error: Error, value: any): void;
  isDirectModified(path: string): boolean;
  isInit(path: string): boolean;
  isModified(path?: string): boolean;
  isSelected(path: string): boolean;
  markModified(path: string): void;
  modifiedPaths(): string[];
  populate<T>(callback?: (err: any, res: T) => void): Document;
  populate<T>(path?: string, callback?: (err: any, res: T) => void): Document;
  populate<T>(opt: PopulateOption, callback?: (err: any, res: T) => void): Document;
  populated(path: string): any;
  remove<T>(callback?: (err: any) => void): Query<T>;
  save<T>(callback?: (err: any, res: T) => void): Promise<T>;
  set(path: string, val: any, type?: new (...args: any[]) => any, options?: Object): void;
  set(path: string, val: any, options?: Object): void;
  set(value: Object): void;
  toJSON(options?: Object): Object;
  toObject(options?: Object): Object;
  toObject<T>(options?: Object): T;
  toString(): string;
  update<T>(doc: Object, options?: Object, callback?: (err: any, affectedRows: number, raw: any) => void): Query<T>;
  validate(cb: (err: any) => void): void;

  isNew: boolean;
  errors: Object;
  schema: Object;
}

export class Aggregate<T> {
  constructor(...options: Object[]);

  append(...options: Object[]): Aggregate<T>;
  group(arg: Object): Aggregate<T>;
  limit(num: number): Aggregate<T>;
  match(arg: Object): Aggregate<T>;
  near(parameters: Object): Aggregate<T>;
  project(arg: string): Aggregate<T>;
  project(arg: Object): Aggregate<T>;
  select(filter: string): Aggregate<T>;
  skip(num: number): Aggregate<T>;
  sort(arg: string): Aggregate<T>;
  sort(arg: Object): Aggregate<T>;
  unwind(fiels: string, ...rest: string[]): Aggregate<T>;

  exec(callback?: (err: any, result: T) => void): Promise<T>;
  read(pref: string, ...tags: Object[]): Aggregate<T>;
}
}
